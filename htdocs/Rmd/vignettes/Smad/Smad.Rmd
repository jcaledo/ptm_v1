---
title: "Smad_Proteins"
author: "Juan Carlos Aledo"
date: "4/22/2020"
output: html_document
---




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(ptm)
setwd("/Users/juancarlosaledo/ptm_outdropbox/ptm/htdocs/Rmd/vignettes/Smad")
```

## GAPDH
```{r}
setwd("/Users/juancarlosaledo/ptm_outdropbox/ptm/htdocs/Rmd/vignettes/GAPDH")
sites <- ptm.scan("P04406")
reg <- reg.scan("P04406")

pos <- sites$n[which(sites$p == TRUE)]
reg <- sites$reg[which(sites$p == TRUE)]
res <- sites$aa[which(sites$p == TRUE)]
ptm <- rep(NA, length(pos))
DG <- rep(NA, length(pos))
regf <- reg


phos <- data.frame(pos = pos, res = res, ptm = ptm, DG = DG, reg = reg, regf = regf)

for (i in 2:nrow(phos)){
  print(i)
  t <- phos$res[i]
  if (t == "S"){
    phos$ptm[i] <- 'pSer'
  } else if (t == "Y"){
    phos$ptm[i] <- 'pTyr'
  } else if (t == "T"){
    phos$ptm[i] <- 'pThr'
  }
  phos$DG[i] <- ddG.ptm('./1u8f_Repair.pdb', 'O', pos = phos$pos[i], ptm = phos$ptm[i])
}
phos$regf[which(phos$regf ==TRUE)] <- "Y"
phos$regf[is.na(phos$reg)] <- "N"

boxplot(as.numeric(phos$DG) ~ phos$regf)
t.test(as.numeric(phos$DG) ~ phos$regf, mu = 0, alt = "less", conf = 0.95, var.eq  = F, paired  = F)

# y42 <- ddG.ptm('1u8f', 'O', pos = 42, ptm = 'pTyr')
# m46 <- ddG.ptm('./1u8f_Repair.pdb', 'O', pos = 46, ptm = 'MetO-Q')
# y94 <- ddG.ptm('./1u8f_Repair.pdb', 'O', pos = 94, ptm = 'pTyr')
# s98 <- ddG.ptm('./1u8f_Repair.pdb', 'O', pos = 98, ptm = 'pSer')
# t99 <- ddG.ptm('./1u8f_Repair.pdb', 'O', pos = 99, ptm = 'pThr')
# s122 <- ddG.ptm('./1u8f_Repair.pdb', 'O', pos = 122, ptm = 'pSer')
# t237 <- ddG.ptm('./1u8f_Repair.pdb', 'O', pos = 237, ptm = 'pThr')
# t246 <- ddG.ptm('./1u8f_Repair.pdb', 'O', pos = 246, ptm = 'pThr')
# 
# # Non Regulatory
# nreg <- sites[which(sites$p & is.na(sites$reg)), ]
# s192 <- ddG.ptm('./1u8f_Repair.pdb', 'O', pos = 192, ptm = 'pSer')
getwd()

```




## MDH
```{r}
setwd("/Users/juancarlosaledo/ptm_outdropbox/ptm/htdocs/Rmd/vignettes/MDH")
a <- foldx.assembly("2dfd", mol1 = 'A', mol2 = 'B')
watermelon <- "P40925"
hcyt <- "P40925"
hmit <- "P40926"
hmit_pdb <- '2df2'
```


## Smad1

Smad1 (por sus siglas en inglés Mothers Against Decantaplegic homolog, donde "decan-tapléjico" se refiere a una proteína de la mosca homóloga a la proteína morfogénica ósea humana), es uno de nueve miembros de la familia Smad, una proteína que, en los humanos, es codificado por el gen SMAD1. Smad1 provoca una cadena de pasos (cascada de señalización o ruta del segundo mensajero) bajo la dirección de la estimulación del factor de crecimiento transformante beta (TGF-beta) y de la proteína morfogénica ósea.

```{r}
# Extraemos las cadenas A, B y C para obtener un fichero PDB del trímero (prescidimos de una cuarta cadena D)

at <- bio3d::read.pdb('1khu')$atom
abc <- at[which(at$chain != "D"), ]
# matrix(c(abc$x, abc$y, abc$z), nrow = 3, byrow = TRUE)

xyz <- c()
for (i in 1:nrow(abc)){
  xyz <- c(xyz, abc$x[i], abc$y[i], abc$z[i])
}

bio3d::write.pdb(file = "./ABC.pdb",
          xyz = xyz, 
          type = rep('ATOM', length(xyz)/3),
          resno = abc$resno,
          resid = abc$resid,
          eleno = abc$eleno,
          elety = abc$elety,
          chain = abc$chain)


rm(at, xyz)
```


searching for the motifs SSXS in the sequence

```{r}
up_smad1 <- pdb2uniprot('1khu', 'A')

seq <- get.seq(up_smad1)
ssxs <- gregexpr("SS[A-W]S", seq)[[1]]

motifs <- c()
for (i in seq_len(length(ssxs))){
  motifs <- c(motifs, substr(seq, ssxs[i], ssxs[i]+3))
}
names(ssxs) <- motifs
ssxs
```


```{r}
psites_smad1 <- p.scan(up_smad1, db = 'PSP')
```

```{r}
pdb <- "./ABC.pdb"
file <- "./Results"
mol1 <- "A"
mol2 <- "B"
pH = 7

## --------- Getting the PDB ----------- ##
  if (nchar(pdb) == 4){
    bio3d::get.pdb(pdb)
    path <- "./"
    id <- pdb
  } else {
    t <- strsplit(pdb, split = "/")[[1]]
    path <- paste(t[-length(t)], collapse = "/")
    id <- strsplit(t[length(t)], "\\.")[[1]][1]
    if (grepl("_Repair", id)){
      id <- strsplit(id, "_")[[1]][1]
    }
  }

## ----- Repair pdb if neccesary -------- ##
  if (file.exists(paste(path, "/", id, "_Repair.pdb", sep = ""))){
    repaired = FALSE
  } else {
    repaired = TRUE
    A <- paste("foldx --command=RepairPDB --pdb=", id, ".pdb --ionStrength=0.05 ",  sep = "")
    B <- paste("--pH=", pH, " --water=CRYSTAL --vdwDesign=2 --pdbHydrogen=false", sep = "")
    AB <- paste(A, B)
    system(AB)
  }


## ------ Complex Analysis --------------- ##
A <- paste("foldx --command=AnalyseComplex --pdb=", id, "_Repair.pdb --analyseComplexChains=", mol1, ",", mol2, sep = "")
B <- paste(" --pdb-dir=", path, " --output-dir=", file, sep = "")
AB <- paste(A, B, sep = "")
system(AB)
```

Interface Residues

```{r}
a <- read.csv2(file = "./Indiv_energies_ABC_Repair_AC.fxout", skip = 8, sep = "\t", fill=TRUE)
b <- read.csv2(file = "./Interaction_ABC_Repair_AC.fxout", skip = 8, sep = "\t", fill=TRUE)

c <- t(read.csv2(file = "./Interface_Residues_ABC_Repair_AC.fxout", header = FALSE, skip = 10, sep = "\t", fill=TRUE))
if (nrow(c) > 0){
  IR <- data.frame(pdb = rep(pdb, nrow(c)),
                 id = c[,1],
                 pos = apply(c, 2, function(x) substr(x, 3, nchar(x))),
                 aa = apply(c, 2, function(x) substr(x, 1, 1)),
                 chain = apply(c, 2, function(x) substr(x, 2, 2)),
                 stringsAsFactors = FALSE)
  IR <- IR[complete.cases(IR), ]
} else {
  IR <- "No interface residues identified"
}
```


Interaction Energy
AnalyseComplex. The interaction between two molecules is driven by the free energy of binding, (ΔGbinding), that is directly related to the thermodynamic dissociation constant (Kd) by the following equation: ΔGbinding = −RT ln(Kd), where R is the gas constant (1.9859 cal mol−1 K−1) and T is the temperature in kelvin. In order to calculate the free energy of binding of a complex AB, FoldX computes the Gibbs energies of the complex (ΔGAB) and of the two molecules A and B alone. The interaction energy is then given by: ΔGbinding = ΔGAB − (ΔGA + ΔGB). The output contains the ΔGbinding for each pair of polypeptide chains in the pdb file, decomposed into the different energy terms used by FoldX (see above) plus an additional term that reflects the intrachain clashes of residues forming part of the interface. This term needs to be considered since a residue that makes a good interaction with another polypeptide chain could go unnoticed in the analysis above when it adopts a strained conformation: the large clash penalty assigned to the unfavourable conformation would more than compensate for the beneficial interaction energy between the polypeptide chains.

```{r}
d <- read.csv2(file = "./Summary_ABC_Repair_AC.fxout", header = TRUE, skip = 8, sep = "\t")
```


## Smad2


```{r}
up_smad2 <- pdb2uniprot('1khx', 'A')
# pdb <- uniprot2pdb(up)
seq_smad2 <- get.seq(up_smad2)
ssxs_smad2 <- gregexpr("SS[A-W]S", seq_smad2)[[1]]

motifs_smad2 <- c()
for (i in seq_len(length(ssxs_smad2))){
  print(i)
  motifs_smad2 <- c(motifs_smad2, substr(seq_smad2, ssxs_smad2[i], ssxs_smad2[i]+3))
}
names(ssxs_smad2) <- motifs_smad2
ssxs_smad2
```


```{r}
```

