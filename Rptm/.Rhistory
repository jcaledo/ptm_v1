env.plot(Z_vitro, aa = 'P', pValue = 0.01)
dev.off()
par(mfrow=c(1,1))
pdf("sulfur.pdf", width = 6, height = 7)
par(mfrow=c(2,2))
env.plot(Z_vivo, aa = 'C', pValue = 0.01)
env.plot(Z_vitro, aa = 'C', pValue = 0.01)
env.plot(Z_vivo, aa = 'M', pValue = 0.01)
env.plot(Z_vitro, aa = 'M', pValue = 0.01)
dev.off()
par(mfrow=c(1,1))
pdf("special.pdf", width = 6, height = 7)
par(mfrow=c(2,2))
env.plot(Z_vivo, aa = 'G', pValue = 0.01)
env.plot(Z_vitro, aa = 'G', pValue = 0.01)
env.plot(Z_vivo, aa = 'P', pValue = 0.01)
env.plot(Z_vitro, aa = 'P', pValue = 0.01)
dev.off()
par(mfrow=c(1,1))
0.25*90
0.25 * 80
0.5 * 25
0.25*70
0.25*65
0.25*60
60/4
p <- c(0, 0.17, 0.29, 0.38, 0.444, 0.5, 0.54, 0.48, 0.62, 0.64, 0.67, 0.75)
p <- c(0, 0.17, 0.29, 0.38, 0.444, 0.5, 0.54, 0.48, 0.62, 0.64, 0.67, 0.75)
s <- 1-p
t <- c(0:10, 15)
plot(t, s)
plot(t, s)
source('~/.active-rstudio-document')
plot(t, s, ty='l')
plot(t, s, ty='b')
d <- 0
plot(t, s, ty='b')
for (i in 1:20){
d <- d + 1/20
abline(h = 1-d)
}
plot(t, s, ty='b')
for (i in 1:20){
d <- d + 1/20
abline(h = 1-d, lty = 2)
}
for (i in 1:20){
d <- d + 1/20
abline(h = 1-d, ty = 2)
}
plot(t, s, ty='b')
for (i in 1:20){
d <- d + 1/20
abline(h = 1-d, ty = 2)
}
warnings
warnings()
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
1/20
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
0.7/8
0.1/4
0.2*0.5
º
5.98E-2/46.07
5.98E-3/46.07
0.13/13.13
0.062/6220
0.12/6220
1000 *0.12/6220
0.161/6220
1000 *0.161/6220
(1000 *0.161/6220)/4
0.019/2
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
lb <- function(data, unit_S = 'mM', unit_v = 'au', weighting = FALSE, plot = TRUE){
## -------------------- Removing incomplete data --------------------- ##
data <- data[complete.cases(data), ]
colnames(data)[1] <- 'S'
## ------------------ Taking double reciprocal ----------------------- ##
tdata <- apply(data, MARGIN = 2, function(x)  1/x)
tdata <- as.data.frame(round(tdata, 4))
names(tdata)[1] <- 'inv_S'
## ---------------- Replicates model fitting ------------------------- ##
Kms <- Vms <- R2 <- c()
for (j in 2:ncol(tdata)){
model <- lm(tdata[,j] ~ tdata$inv_S )
Vm <- round(1/model$coefficients[1], 2)
Km <- round(Vm * model$coefficients[2], 2)
Vms <- c(Vms, Vm)
Kms <- c(Kms, Km)
R2 <- c(R2,  summary(model)$r.squared)
}
## ---- Computing mean and sd if required of the transformed data ---- ##
if (ncol(tdata) > 2){
tdata$inv_v <- round(apply(tdata[,-1], MARGIN = 1, mean), 4)
tdata$sd <- round(apply(tdata[,-c(1, ncol(tdata))], MARGIN = 1, sd), 4)
} else {
names(tdata)[2] <- 'inv_v'
}
## ------------------ Mean model fitting ----------------------------- ##
if (weighting){
model <- lm(tdata$inv_v ~ tdata$inv_S, weights = 1/(tdata$inv_v)^4)
} else {
model <- lm(tdata$inv_v ~ tdata$inv_S)
}
Vm <- round(1/model$coefficients[1], 2)
Km <- round(Vm * model$coefficients[2], 2)
## -------------- Plotting the transformed data ---------------------- ##
if (plot == TRUE){
parameters <- paste('Km: ', Km, '     Vm: ', Vm, sep = "")
plot(tdata$inv_S, tdata$inv_v, ty = 'p',
ylim = c(0, max(tdata[,-1]) + 0.1*max(tdata[,-1])),
xlab = paste('1/[S] (1/', unit_S, ')', sep = ""),
ylab = paste('1/v (1/', unit_v, ')', sep = ""), main = parameters)
abline(model)
if (ncol(tdata) > 2){
arrows(tdata$inv_S, tdata$inv_v - tdata$sd,
tdata$inv_S, tdata$inv_v + tdata$sd,
length=0.05, angle=90, code=3)
}
}
fitted_parameters <- c(Km, Vm)
names(fitted_parameters) <- c('Km', 'Vm')
output <- list(unname(Kms), unname(Vms), R2, fitted_parameters, tdata)
names(output) <- c('Kms', 'Vms', 'R2s', 'fitted_parameters', 'inverse_data')
return(output)
}
ecb <- function(data, unit_S = 'mM', unit_v = 'au', plot = TRUE){
## -------------------- Variables' names ---------------------- ##
colnames(data)[1] <- 'S'
colnames(data)[2:length(colnames(data))] <- LETTERS[1:length(colnames(data)) - 1]
data <- data[complete.cases(data), ]
## -------------------- Computing v/[S] ----------------------- ##
if (ncol(data) > 2){
tdata <- apply(data[,-1], MARGIN = 2, function(x)  x/data[,1])
mean_v <- apply(data[,-1], MARGIN = 1, mean)
mean_v_S <- apply(tdata, MARGIN = 1, mean)
} else {
tdata <- data[,2]/data[,1]
mean_v <- data[,2]
mean_v_S <- tdata
}
tdata <- as.data.frame(tdata)
names(tdata)[1] <- 'v_S'
tdata <- cbind(data, tdata)
names(tdata)[2] <- 'v'
nc <- ncol(data) + 1 # number of the first colum for v/S data
## ------------- Pair-wise intersection and median ----------- ##
line.intersect <- function(v, v_S){
Kms <- Vms <- c()
for (i in 1:(length(v)-1)){
for (j in (i+1):length(v)){
Km <- (v[j] - v[i])/(v_S[i] - v_S[j])
Kms <- c(Kms, Km)
Vm <- (v_S[i]*(v[j] - v[i])/(v_S[i] - v_S[j])) + v[j]
Vms <- c(Vms, Vm)
}
}
Km <- median(Kms, na.rm = TRUE)
Vm <- median(Vms, na.rm = TRUE)
return(c(Km, Vm))
}
## ------------------------------------------------------------ ##
## --------------------- Estimating Km and Vm ----------------- ##
Kms <- Vms <- c()
c <- 0
for (i in 2:(nc - 1)){
p <- line.intersect(tdata[,i], tdata[,nc + c])
Kms <- c(p[1], Kms)
Vms <- c(p[2], Vms)
c <- c + 1
}
Km <- paste('Km: ', round(mean(Kms), 3), ' \u00b1 ', round(sd(Kms), 3), ' ', unit_S)
Vm <- paste('Vm: ', round(mean(Vms), 3), ' \u00b1 ', round(sd(Vms), 3), ' ', unit_v)
fitted_parameters <- c(round(mean(Kms, na.rm = TRUE), 3),  round(mean(Vms, na.rm = TRUE), 3))
names(fitted_parameters) <- c('Km', 'Vm')
## --------------------- Plotting results --------------------- ##
if (plot){
plot(0, 0, ty = 'n',
xlim = c(-tdata$S[nrow(tdata)], tdata$S[nrow(tdata)]),
ylim = c(0, 3*max(tdata$v, na.rm = TRUE)),
xlab = paste("Km (", unit_S, ")", sep = ""),
ylab = paste("Vm (", unit_v, ")", sep = ""))
for (i in 1:nrow(tdata)){
points(c(0, -tdata$S[i]), c(mean_v[i], 0), pch = 20)
abline(mean_v[i], mean_v_S[i])
}
abline(v = 0, lty = 2)
abline(h = 0, lty = 2)
}
output <- list(fitted_parameters, Km, Vm)
names(output) <- c('fitted_parameters', 'Km', 'Vm')
return(output)
}
dir.MM <- function(data, unit_S = 'mM', unit_v = 'au', plot = TRUE){
## -------------------- Removing incomplete data -------------------- ##
data <- data[complete.cases(data), ]
## --------------------- Estimating the seed ------------------------ ##
t <- ecb(data, plot = FALSE)
K <- t$fitted_parameters[1]
V <- t$fitted_parameters[2]
seed = list(Km = K, Vm = V)
## ---------------------- Fitting the curve ------------------------- ##
names(data) <- c('S', 'v')
model <- nls(data$v ~ (Vm * data$S)/(Km + data$S), data =  data, start = seed )
## --------------------- Computing parameters ----------------------- ##
Km <- round(summary(model)$coefficient[1,1], 3)
sd_Km <- round(summary(model)$coefficient[1,2], 3)
Vm <- round(summary(model)$coefficient[2,1], 3)
sd_Vm <- summary(model)$coefficient[2,2]
## -------------------- Fitted velocity values ---------------------- ##
mm.eq <- function(x) {(Vm * x)/(Km + x)}
data$fitted_v <- mm.eq(data$S)
## --------------- Plotting the transformed variables --------------- ##
if (plot){
parameters <- paste('Km: ', Km, '     Vm: ', Vm, sep = "")
plot(data$S, data$v,
xlab = paste("[S] (", unit_S, ")", sep = ""),
ylab = paste("v (", unit_v, ")", sep = ""),
main = parameters)
x <- seq(from = 0, to = max(data$S), by = max(data$S)/1000)
y <- mm.eq(x)
points(x, y, ty = 'l')
}
## -------------------------- Output ------------------------------- ##
KmVm <- c(Km, Vm)
names(KmVm) <- c("Km", "Vm")
output <- list(KmVm, data)
names(output) <- c('parameters', 'data')
return(output)
}
data <- data.frame(S = c(0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 8, 20),
v = c(1.8, 5.2, 15, 28.3, 51, 75.4, 112.7, 126.1, 154.9))
View(data)
dir.MM(data)
ecb(data)
dir.MM(data, unit_v = "mM/min")
ecb(data, unit_v = "mM/min")
lb(data, unit_v = "mM/min")
dir.MM(data, unit_v = "mM/min")
ecb(data)
lb(data)
lb(data, weighting = TRUE)
getwd()
getwd()
library(ptm)
getwd()
library(ptm)
?INSTALL
install.packages(c("backports", "bit", "bit64", "bookdown", "broom", "callr", "car", "chron", "cli", "clipr", "codetools", "conquer", "covr", "cowplot", "dbplyr", "devtools", "dplyr", "DT", "fs", "ggdendro", "ggforce", "glue", "gplots", "htmltools", "htmlwidgets", "httr", "igraph", "jsonlite", "knitr", "later", "lubridate", "maptools", "MASS", "matrixStats", "mgcv", "mosaic", "mosaicCore", "mosaicData", "network", "nlme", "NLP", "openssl", "openxlsx", "processx", "promises", "ps", "qdap", "quantreg", "raster", "RcppArmadillo", "readr", "remotes", "rlang", "rmarkdown", "roxygen2", "RSQLite", "rvest", "segmented", "seqinr", "sp", "stringdist", "stringi", "survival", "sys", "tibble", "tidyr", "tidytext", "tinytex", "usethis", "vctrs", "withr", "xfun", "xlsx", "XML", "zip"))
library(ptm)
library(ptm)
devtools::check()
library(bio3d)
ls()
ls
system()
?system
ls()
library(bio3d)
ls()
sessionInfo()
library()
.packages()
(.packages())
devtools::install_deps(dependencies = TRUE)
has_devel()
library(devtools)
has_devel()
search()
.libPaths()
library(ptm)
library(ptm)
library(ptm)
?meto.search
?saro.motif
library(ptm)
library(ptm)
library(ptm)
a <- prot2codon("P01009")
prot <- "P01009"
chain <- ""
laxity <- TRUE
## ---------- Primary structure of the protein ----------- ##
if (regexpr("/",prot)[[1]] != -1){ # input is path to a local pdb file
mypdb <- bio3d::read.pdb(prot)$atom
seq <- bio3d::aa321(mypdb$resid[which(mypdb$elety == 'CA' &
mypdb$chain == chain)])
t <- strsplit(prot, split = "/")[[1]]
t <- t[length(t)]
t <- substring(t, 1,4)
source <- 'pdb'
} else if (nchar(prot) == 4){ # input is PDB ID
id <- paste(prot, chain, sep = ":")
seq <- get.seq(id, db = 'pdb', as.string = FALSE)[[1]]
t <- prot
source <- 'pdb'
} else { # input should be a uniprot ID
seq <- get.seq(prot, as.string = FALSE)[[1]]
t <- prot
source <- 'uniprot'
}
seq <- get.seq(prot, as.string = FALSE)[[1]]
seq <- get.seq(prot)[[1]]
seq
seq <- ptm::get.seq(prot, as.string = FALSE)[[1]]
rm(seq)
## ---------- Primary structure of the protein ----------- ##
if (regexpr("/",prot)[[1]] != -1){ # input is path to a local pdb file
mypdb <- bio3d::read.pdb(prot)$atom
seq <- bio3d::aa321(mypdb$resid[which(mypdb$elety == 'CA' &
mypdb$chain == chain)])
t <- strsplit(prot, split = "/")[[1]]
t <- t[length(t)]
t <- substring(t, 1,4)
source <- 'pdb'
} else if (nchar(prot) == 4){ # input is PDB ID
id <- paste(prot, chain, sep = ":")
seq <- get.seq(id, db = 'pdb', as.string = FALSE)[[1]]
t <- prot
source <- 'pdb'
} else { # input should be a uniprot ID
seq <- get.seq(prot, as.string = FALSE)[[1]]
t <- prot
source <- 'uniprot'
}
## ---------- Primary structure of the protein ----------- ##
if (regexpr("/",prot)[[1]] != -1){ # input is path to a local pdb file
mypdb <- bio3d::read.pdb(prot)$atom
seq <- bio3d::aa321(mypdb$resid[which(mypdb$elety == 'CA' &
mypdb$chain == chain)])
t <- strsplit(prot, split = "/")[[1]]
t <- t[length(t)]
t <- substring(t, 1,4)
source <- 'pdb'
} else if (nchar(prot) == 4){ # input is PDB ID
id <- paste(prot, chain, sep = ":")
seq <- ptm::get.seq(id, db = 'pdb', as.string = FALSE)[[1]]
t <- prot
source <- 'pdb'
} else { # input should be a uniprot ID
seq <- ptm::get.seq(prot, as.string = FALSE)[[1]]
t <- prot
source <- 'uniprot'
}
## ------------------- Output structure -------------------- ##
output <- as.data.frame(matrix(rep(NA, length(seq)*5), ncol = 5))
names(output) <- c('id', 'chain', 'pos', 'aa', 'codon')
output$id <- prot
if (chain == ""){
output$chain <- NA
} else {
output$chain <- chain
}
output$pos <- 1:length(seq)
output$aa <- seq
## ----------------- Finding the codons ------------------ ##
organism <- species.mapping(t, db = source)
if (source == 'pdb'){
t <- pdb2uniprot(t, chain = chain)
}
kegg_id <- id.mapping(t, from = 'uniprot', to = 'kegg')[1]
kegg_id[1] == "Sorry, no KEGG ID could be found!"
dna <- get.seq(kegg_id, 'kegg-nt')
dna <- ptm::get.seq(kegg_id, 'kegg-nt')
codon <- gsub("(.{3})", "\\1 ", dna)
codon <- strsplit(codon, split = " ")[[1]]
if (requireNamespace('seqinr', quietly = TRUE)){
translated <- seqinr::translate(seqinr::s2c(dna))
} else {
stop("The package seqinr must be installed to use this function")
}
sequences <- c(paste(seq, collapse = ""),
paste(translated, collapse = ""))
aln <- msa(sequences)
sequences
?msa
aln <- msa(sequences, c("query", "translated"))
k <- 1
j <- 1
for (i in 1:dim(aln$ali)[2]){
if (aln$ali[1,i] == aln$ali[2,i]){
output$codon[k] <- codon[j]
k <- k + 1
j <- j + 1
} else if (aln$ali[1,i] == '-'){
j <- j +1
} else if (aln$ali[2,i] == '-'){
output$codon[k] <- NA
k <- k + 1
} else { # mismatch
output$codon[k] <- codon[j]
k <- k + 1
j <- j + 1
}
}
## ------------ Cheking the translation -------------------- ##
triplet <- c("GCU", "GCC", "GCA", "GCG", "CGU", "CGC", "CGA", "CGG", "AGA", "AGG", "AAU", "AAC",
"GAU", "GAC", "UGU", "UGC", "CAA", "CAG", "GAA", "GAG", "GGU", "GGC", "GGA", "GGG",
"CAU", "CAC", "AUU", "AUC", "AUA", "UUA", "UUG", "CUU", "CUC", "CUA", "CUG", "AAA",
"AAG", "AUG", "UUU", "UUC", "CCU", "CCC", "CCA", "CCG", "UCU", "UCC", "UCA", "UCG",
"AGU", "AGC", "ACU", "ACC", "ACA", "ACG", "UGG", "UAU", "UAC", "GUU", "GUC", "GUA",
"GUG", "UAA", "UGA", "UAG")
aa <- c("A","A","A","A","R","R","R","R","R","R","N","N","D","D","C","C","Q","Q","E","E",
"G","G","G","G","H","H","I","I","I","L","L","L","L","L","L","K","K","M","F","F",
"P","P","P","P","S","S","S","S","S","S","T","T","T","T","W","Y","Y","V","V","V",
"V","Stop","Stop","Stop")
names(triplet) <- aa
triplet <- gsub("U", "T", triplet)
output$check <- NA
for (i in 1:nrow(output)){
if (!is.na(output$codon[i])){
t <- as.character(output$codon[i])
if (!laxity){
if (output$aa[i] != names(triplet)[which(triplet == t)]){
stop(paste("Problem at ", i))
}
}
output$check[i] <- (output$aa[i] == names(triplet)[which(triplet == t)])
}
}
if (!laxity){
if (sum(output$check) != nrow(output)) { stop("Translation problem")}
}
View(output)
rm(list = ls())
library(ptm)
stringi::stri_escape_unicode(*)
stringi::stri_escape_unicode("*")
cat(stringi::stri_escape_unicode("*"))
x <- "this is a bullet *"
y <- "this is a bullet \u2022"
x
y
x <- "this is a bullet •"
x == y
?stri_escape_unicode
rm(x,y)
x <- "this is *"
x
cat(stringi::stri_escape_unicode(x))
cat(stringi::stri_escape_unicode(x))
x <- "this is a bullet •"
x
cat(stringi::stri_escape_unicode(x))
x <- @
x <- '@'
x
cat(stringi::stri_escape_unicode(x))
x <- '•'
x
cat(stringi::stri_escape_unicode(x))
4*7
?tools::showNonASCII()
tools::showNonASCIIfile("/Users/juancarlosaledo/ptm_outdropbox/ptm/Rptm/R/ddG.R")
x <- "Temperature has been set to 25ºC"
x
cat(stringi::stri_escape_unicode(x))
war <- "Temperature has been set to 25\u00baC"
war
cat(stringi::stri_escape_unicode("ΔΔG"))
?ddG.ptm
?ddG.ptm
devtools::load_all(".")
library(ptm)
1/310
273+30
1/303
Ea <- 50
Te <- 298
Ea <- 50
0.00831 * Te -> RT
273+35
Te <- 308
0.00831 * Te -> RT
Te <- 298
Ea <- 50
0.00831 * Te -> RT
H <- 50 - RT
Te <- 308
0.00831 * Te -> RT
H <- 50 - RT
Te <- 298
Ea <- 100
0.00831 * Te -> RT
H <- 50 - RT
Te <- 308
Ea <- 100
0.00831 * Te -> RT
H <- 50 - RT
Ea <- 100
0.00831 * Te -> RT
H <- Ea - RT
Te <- 298
Ea <- 100
0.00831 * Te -> RT
H <- Ea - RT
rm(list =ls())
